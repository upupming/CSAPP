### 3.1 总体设计

1. `mm-implicit.c`是基于隐式空闲链表的首次适配，并且使用带边界标记的合并，但缺少空闲块合并函数的代码实现。

2. 在完成`mm-implicit.c`的`coalesce`函数之后，进一步将带边界标记的隐式块结构优化为显示空闲链表，即分配块被释放时，将原来的有效载荷变为`pred`（祖先）和`succ`（后继）。  
	每个块都有下图所示的header和footer：  

		31                     3  2  1  0 
		-----------------------------------
		| s  s  s  s  ... s  s  s  0  0  a/f
		----------------------------------- 

	空闲链表的格式如下图：
		begin                                                          end
		heap                                                           heap  
		-----------------------------------------------------------------   
		|  pad   | hdr(8:a) | ftr(8:a) | zero or more usr blks | hdr(8:a) |
		-----------------------------------------------------------------
		  |       prologue      |                       | epilogue |
		  |         block       |                       | block    |
	其中序言块（prologue block）和结尾块（epilogue block）用来消除合并时的边界条件。它们中间才是由`mm_malloc`创建的普通块。

3. 最后使用**分离的空闲链表（segregated storage）**（课本9.9.14）进行优化。

    这样的分配器维护一个空闲链表的数组，类似于BST（二叉查找树），搜索效率显著提高。

    简单分离存储（simple segregated storage）使用的是单向链表，每个片中都是大小相等的块，不分割，不合并。由于不需要头部和尾部，空闲块只需要`succ`指针，内存开销很少，但很容易产生内部和外部碎片。  
    分离适配（segregated fit）是GNU malloc包中采用的方式，首次适配查找，将剩余空闲链表空间插入到数组的合适位置。  
    伙伴系统（buddy system）是分离适配的特例，每个大小类都是2的幂，即每个空闲块大小都是2^k(0 <= k <= m)，堆的总大小为

    优化后的分配器使用的是伙伴系统方式。


