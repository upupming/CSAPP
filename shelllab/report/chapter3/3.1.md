### 3.1 void eval(char *cmdline)函数

#### 函数功能  

对用户输入的命令行进行求值。  
若用户输入内置shell命令（`quit`、`jobs`、`bg`、`fg`），立即执行，若用户输入的是一个可执行目标文件，则在一个新的子进程的上下文中加载并运行这个文件。如果任务在前台运行，会等待它终止并返回。  
每个子进程必须有独一无二的进程组ID，这样当按下CTRL+C（CTRL+Z）时，后台子进程不会接收到来自内核的SIGINT（SIGTSTP）信号。  

#### 参数

char *cmdline：用户输入的字符串

#### 处理流程

1. 调用`parseline`解析以空格分隔的命令行参数，并构造最终会传递给`execve`的argv向量。
2. 调用`builtin_cmd`检查第一个命令行参数是否是一个内置的shell命令。如果是，立即执行，并返回1，否则返回0。
3. 如果`builtin_cmd`返回0，那么shell创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序（“&”），那么shell返回到循环的顶部，等待下一个命令行；否则，shell使用`waitpid`等待作业终止。当作业终止时，shell就开始下一轮迭代。

#### 要点分析

1. 对错误的处理：忽略空行，每次函数执行出错时都要执行错误处理程序。
2. 如果命令不是内置shell命令，首先要阻塞SIGCHLD、SIGINT、SIGTSTP信号，这样shell进程本身就不会被终止，等到创建了子进程，才可以取消对这3个信号的阻塞。
3. 对于新任务，每个都需要运行在一个新的进程组中，这样按下CTRL+C或CTRL+Z时内核就不会杀死所有进程。
